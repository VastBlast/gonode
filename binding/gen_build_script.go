package binding

import (
	"encoding/json"
	"path/filepath"

	"github.com/wenlng/gonacli/config"
	"github.com/wenlng/gonacli/tools"
)

func GenBuildScriptFile(cfgs config.Config, filename string, moduleRoot string) bool {
	outputDir := tools.FormatDirPath(cfgs.OutPut)
	moduleRootRel := ""
	if len(moduleRoot) > 0 {
		if rel, err := filepath.Rel(outputDir, moduleRoot); err == nil {
			moduleRootRel = filepath.ToSlash(rel)
		} else {
			moduleRootRel = filepath.ToSlash(moduleRoot)
		}
	}

	sourcePaths := make([]string, 0, len(cfgs.Sources))
	for _, src := range cfgs.Sources {
		absSrc := src
		if !filepath.IsAbs(absSrc) {
			absSrc = filepath.Join(tools.GetPWD(), src)
		}

		if len(moduleRoot) > 0 {
			if rel, err := filepath.Rel(moduleRoot, absSrc); err == nil {
				sourcePaths = append(sourcePaths, filepath.ToSlash(rel))
				continue
			}
		}
		sourcePaths = append(sourcePaths, filepath.ToSlash(src))
	}

	sourceJSON, err := json.Marshal(sourcePaths)
	if err != nil {
		return false
	}

	exportNames := make([]string, 0, len(cfgs.Exports))
	for _, export := range cfgs.Exports {
		exportNames = append(exportNames, export.Name)
	}
	exportsJSON, err := json.Marshal(exportNames)
	if err != nil {
		return false
	}

	nameJSON, err := json.Marshal(cfgs.Name)
	if err != nil {
		return false
	}

	moduleRootJSON, err := json.Marshal(moduleRootRel)
	if err != nil {
		return false
	}

	code := `// Auto-generated by gonacli
'use strict';

const { spawnSync } = require('child_process');
const path = require('path');
const { join, resolve } = path;
const fs = require('fs');

const config = {
  name: ` + string(nameJSON) + `,
  sources: ` + string(sourceJSON) + `,
  exports: ` + string(exportsJSON) + `,
};

const rootDir = __dirname;
const isWin = process.platform === 'win32';
const nodeBin = process.execPath;
const nodeGypFromEnv = process.env.npm_config_node_gyp;
const goCmd = process.env.GO_BINARY || 'go';
const moduleRootRel = ` + string(moduleRootJSON) + `;
const moduleRoot = moduleRootRel ? resolve(rootDir, moduleRootRel) : rootDir;

function run(cmd, args) {
  const result = spawnSync(cmd, args, { cwd: rootDir, stdio: 'inherit' });
  if (result.error) {
    const err = new Error(result.error.message || String(result.error));
    err.code = typeof result.error.code === 'number' ? result.error.code : 1;
    err.errno = typeof result.error.code === 'string' ? result.error.code : undefined;
    throw err;
  }
  if (result.status !== 0) {
    const statusCode = typeof result.status === 'number' ? result.status : 1;
    const err = new Error(cmd + ' ' + args.join(' ') + ' failed with code ' + statusCode);
    err.code = statusCode;
    err.status = statusCode;
    throw err;
  }
}

function tryRun(cmd, args) {
  const result = spawnSync(cmd, args, { cwd: rootDir, stdio: 'inherit' });
  if (result.error) {
    if (result.error.code === 'ENOENT') {
      return { ok: false, missing: true };
    }
    const err = new Error(result.error.message || String(result.error));
    err.code = typeof result.error.code === 'number' ? result.error.code : 1;
    throw err;
  }
  if (result.status !== 0) {
    const statusCode = typeof result.status === 'number' ? result.status : 1;
    const err = new Error(cmd + ' ' + args.join(' ') + ' failed with code ' + statusCode);
    err.code = statusCode;
    err.status = statusCode;
    throw err;
  }
  return { ok: true, missing: false };
}

function buildGo() {
  console.log('Building Go c-archive ...');
  const goCheck = tryRun(goCmd, ['version']);
  if (!goCheck.ok && goCheck.missing) {
    throw new Error('Go toolchain not found. Please install Go and ensure "' + goCmd + '" is in PATH, or set GO_BINARY to the Go executable.');
  }
  const args = ['build', '-buildmode=c-archive', '-o', join(rootDir, config.name + '.a')];
  for (const src of config.sources) {
    args.push(join(moduleRoot, src));
  }
  const workDir = moduleRoot || rootDir;
  const result = spawnSync(goCmd, args, { cwd: workDir, stdio: 'inherit' });
  if (result.error) {
    const err = new Error(result.error.message || String(result.error));
    err.code = typeof result.error.code === 'number' ? result.error.code : 1;
    err.errno = typeof result.error.code === 'string' ? result.error.code : undefined;
    throw err;
  }
  if (result.status !== 0) {
    const statusCode = typeof result.status === 'number' ? result.status : 1;
    const err = new Error('go build -buildmode=c-archive failed with code ' + statusCode);
    err.code = statusCode;
    err.status = statusCode;
    throw err;
  }
}

function patchWindowsHeader() {
  const headerPath = join(rootDir, config.name + '.h');
  if (!fs.existsSync(headerPath)) {
    throw new Error('Missing generated header file: ' + headerPath);
  }

  const patched = fs
    .readFileSync(headerPath, 'utf8')
    .split(/\r?\n/)
    .map((line) => {
      if (line.startsWith('#line 1') && line.includes('cgo-builtin-export-prolog')) {
        return '/*' + line + '*/';
      }
      if (line.startsWith('#line 1') && line.includes('cgo-gcc-export-header-prolog')) {
        return '/*' + line + '*/';
      }
      if (line.startsWith('typedef') && line.includes('GoUintptr')) {
        return '/*' + line + '*/';
      }
      if (line.startsWith('typedef') && line.includes('GoComplex64')) {
        return '/*' + line + '*/';
      }
      if (line.startsWith('typedef') && line.includes('GoComplex128')) {
        return '/*' + line + '*/';
      }
      return line;
    })
    .join('\n');

  fs.writeFileSync(headerPath, patched.endsWith('\n') ? patched : patched + '\n', 'utf8');
}

function writeDefFile() {
  const defPath = join(rootDir, config.name + '.def');
  const lines = ['EXPORTS', ...config.exports.map((name) => '  ' + name)];
  fs.writeFileSync(defPath, lines.join('\n') + '\n', 'utf8');
  return defPath;
}

function buildWindowsArtifacts(defPath) {
  const dllName = config.name + '.dll';
  const goLib = config.name + '.a';
  console.log('Building Windows dll/lib ...');

  run('gcc', [defPath, goLib, '-shared', '-lwinmm', '-lWs2_32', '-o', dllName, '-Wl,--out-implib,' + config.name + '.dll.a']);

  const machine = process.arch === 'ia32' ? 'X86' : 'X64';
  const libRes = tryRun('lib', ['/def:' + defPath, '/name:' + dllName, '/out:' + config.name + '.lib', '/MACHINE:' + machine]);
  if (!libRes.ok && libRes.missing) {
    const dllToolRes = tryRun('dlltool', ['-d', defPath, '-D', dllName, '-l', config.name + '.lib']);
    if (!dllToolRes.ok && dllToolRes.missing) {
      throw new Error('Missing \"lib\" (Visual Studio) or \"dlltool\" (MinGW). Install one of them to produce the import library.');
    }
  }
}

function getNodeGypRunners() {
  const runners = [];
  if (nodeGypFromEnv) {
    runners.push({ cmd: nodeBin, args: [nodeGypFromEnv] });
  }
  if (isWin) {
    runners.push({ cmd: 'node-gyp.cmd', args: [] });
    runners.push({ cmd: 'npx.cmd', args: ['node-gyp'] });
  } else {
    runners.push({ cmd: 'node-gyp', args: [] });
    runners.push({ cmd: 'npx', args: ['node-gyp'] });
  }
  return runners;
}

function buildAddon(debug) {
  const args = ['rebuild'];
  if (debug) {
    args.push('--debug');
  }
  const errors = [];
  for (const runner of getNodeGypRunners()) {
    try {
      run(runner.cmd, [...runner.args, ...args]);
      return;
    } catch (err) {
      const errno = err && err.errno ? err.errno : err && err.code ? err.code : '';
      const message = err && err.message ? err.message : String(err);
      errors.push(runner.cmd + ' ' + [...runner.args, ...args].join(' ') + ' -> ' + (errno ? errno + ' ' : '') + message);
      if (errno === 'ENOENT' || errno === 'EINVAL') {
        continue;
      }
      if (typeof err.status === 'number' || typeof err.code === 'number') {
        throw err;
      }
    }
  }
  throw new Error('Failed to run node-gyp via any runner. Tried: ' + errors.join('; '));
}

(() => {
  try {
    const debug = process.argv.includes('--debug');
    buildGo();
    if (isWin) {
      patchWindowsHeader();
      const defPath = writeDefFile();
      buildWindowsArtifacts(defPath);
    }
    buildAddon(debug);
  } catch (err) {
    console.error(err && err.stack ? err.stack : err && err.message ? err.message : err);
    const exitCode = typeof err?.code === 'number' ? err.code : 1;
    process.exit(exitCode);
  }
})();
`

	writeBuildScriptFile(code, filename, cfgs.OutPut)
	return true
}

func writeBuildScriptFile(content string, filename string, outPath string) {
	outputDir := tools.FormatDirPath(outPath)
	tools.WriteFile(content, outputDir, filename)
}
